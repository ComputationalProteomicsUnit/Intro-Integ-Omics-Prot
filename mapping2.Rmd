# Multiple transcipts per protein

```{r env, echo=FALSE}
suppressPackageStartupMessages(library("Pbase"))
library("knitr")
opts_chunk$set(fig.width=12, fig.height=7)
library("rtracklayer")
data(p)
```
Illustration with the
[`Pbase`](http://bioconductor.org/packages/devel/bioc/html/Pbase.html)
Bioconductor package (devel version).

## Data

We have an example data, named `p`, composed of `r length(p)`
proteins, with UniProt accession numbers and Ensembl transcipt
identifers and each protein has a set experimentally observed
peptides:

```{r ids, echo=FALSE}
kable(cbind(Acc = seqnames(p),
            ENST = acols(p)$ENST,
            npep = elementLengths(pranges(p))),
      row.names = 0)
```

If we hadn't the curated UniProt accession/Ensembl transcript
identifer maps, we would, for example, query an online repositary such
as the Ensembl Biomart instance.

```{r ens}
library("biomaRt")
ens <- useMart("ensembl", "hsapiens_gene_ensembl")
ens
```

```{r bm}
bm <- select(ens, keys = seqnames(p),
             keytype = "uniprot_swissprot_accession",
             columns = c(
                 "uniprot_swissprot_accession",
                 "ensembl_transcript_id"))

bm
```

```{r bm2, echo=FALSE}
k <- 6
sel <- bm$uniprot_swissprot_accession == seqnames(p)[k]
bm2 <- bm[sel, ]
eid <- bm2[, 2]
names(eid) <- bm2[, 1]
```

If we focus on `r seqnames(p)[k]` for example, we see that we
retrieve `r nrow(bm2)` possible transcript identifers, including our
annotated `r acols(p)$ENST[k]`.

```{r bm2tab, echo=FALSE}
kable(bm2, row.names = 0)
```

## Genomic coordinates

Let's fetch the coordinates of all possible transcipts, making sure
that the names of the Ensembl identifiers are used to name the grl
ranges (using `use.names = TRUE`). We obtain 30 sets of ranges for 9
proteins.

```{r pcgrl}
eid
grl <- etrid2grl(eid, ens, use.names = TRUE)
pcgrl <- proteinCoding(grl)
```

```{r givtr}
grTr <- lapply(pcgrl, function(i)
    GeneRegionTrack(i, name = mcols(i)$transcript[1]))

plotTracks(grTr)
```

## Discriminating transcripts

```{r protfromgenome, echo=FALSE, message=FALSE}
library("BSgenome.Hsapiens.NCBI.GRCh38")
if (!"chr1" %in% seqnames(BSgenome.Hsapiens.NCBI.GRCh38))
    seqnames(BSgenome.Hsapiens.NCBI.GRCh38)[1:23] <-
        paste0("chr", seqnames(BSgenome.Hsapiens.NCBI.GRCh38)[1:23])
```

We extract the transcript sequences, translate them into protein
sequences and align each to our original protein sequence.

```{r aln, warnings=FALSE}
library("BSgenome.Hsapiens.NCBI.GRCh38")
lseq <- lapply(getSeq(BSgenome.Hsapiens.NCBI.GRCh38, pcgrl),
               function(s) translate(unlist(s)))

laln <- sapply(lseq, pairwiseAlignment, aa(p[k]))
sapply(laln, nmatch)/width(aa(p[k]))
```

```{r align, echo=FALSE}
ki <- which.max(sapply(laln, nmatch))
writePairwiseAlignments(laln[[ki]])
```

We see that transcript number `r ki`, `r eid[ki]`, perfectly aligns
with our protein sequence. This is also the transcipt that corresponds
to the curated Ensembl transcript in `acols(p)$ENST`.

```{r checkk, echo=FALSE}
stopifnot(eid[ki] == acols(p)$ENST[k])
```

```{r map}
res <- pmapToGenome(p[k], pcgrl[ki])
res <- res[[1]]
```

```{r pepcoords2, echo=FALSE}


pepTr <- AnnotationTrack(start = start(res),
                         end = end(res),
                         chr = chrom(res),
                         strand = strand(res),
                         id = mcols(res)$pepseq,
                         group = mcols(res)$group,
                         fill = ifelse(mcols(res)$exonJunctions, "red", "steelblue"),
                         col = NULL,
                         name = mcols(res)$transcript[1])

plotTracks(list(grTr[[ki]], pepTr))
```
