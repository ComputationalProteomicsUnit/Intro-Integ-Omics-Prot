# Proteomics data: caveats

```{r env, echo=FALSE, warning=FALSE}
suppressPackageStartupMessages(library("Pbase"))
suppressPackageStartupMessages(library("MSnbase"))
library("knitr")
```

**Mapping** of *peptides along protein sequences (although not
  explicitly considered a mapping exercise)* and *short reads along
  genome coordinates*.

But...

## Coverage

- Coverage in proteomics in `%`
- [Coverage](http://www.ncbi.nlm.nih.gov/pubmed/24434847) in RNA-Seq in fold `X`

The following values are higher bounds, *without* peptide filtering for
about 80000 *gene groups* 

```{r cvg, echo=FALSE, fig.width=12}
cvg <- data.table::fread("./data/Ensembl_76.csv", skip = 17,
                         stringsAsFactors = FALSE)
sel <- cvg$length > 100 & cvg$length < 10000
cvg <- cvg[sel, ]
hist(cvg$coverage, breaks = 100, xlab = "coverage", main = "")
```

## Protein inference

<!-- ![Basic peptide grouping](./figure/F5.large.jpg) -->


![Peptide evidence classes](./figure/nbt0710-647-F2.gif)

From [Qeli and Ahrens (2010)](http://www.ncbi.nlm.nih.gov/pubmed/20622826).
See also [Nesvizhskii and Aebersold (2005)](http://www.ncbi.nlm.nih.gov/pubmed/16009968).

Often, in proteomics experiments, the features represent single
proteins and **groups** of indistinguishable or non-differentiable
proteins identified by shared (non-unique) peptides.

**Caveat**: Mapping between protein groups and unique transcripts?

## Mapping protein and gene identifers

The protein database and the genome are _independent_, i.e. the
proteins do not make explicitly reference to the genome they originate
from.

![DB in proteomics](./figure/indep-prot-db.png)

![linking with genomics](./figure/gen-prot-db.png)

If we want to map UniProt accession to genomic identifiers (Ensembl
transcipt identifiers):


```{r ids, cache=TRUE, echo=FALSE}
## The UniProt human proteome (release 2015_02)
library("Pbase")
up <- Proteins("data/HUMAN_2015_02.fasta.gz")

## Using the accession number to Ensembl Biomart query
## for transcript identifiers
library("biomaRt")
ens <- useMart("ensembl", "hsapiens_gene_ensembl")
upbm <- select(ens, keys = seqnames(up),
               keytype = "uniprot_swissprot_accession",
               columns = c(
                   "uniprot_swissprot_accession",
                   "ensembl_transcript_id"))
```

- The UniProt human proteome (release 2015_02) has `r length(up)` entries.

- If we query the Ensembl Biomart server for their transcript
  identifiers, we obtain results for `r length(unique(upbm$uniprot_swissprot_accession))`.


```{r ids1, echo=FALSE}
## How many UniProt accession with Ensembl transcripts were found?
tab <- rbind(table(seqnames(up) %in% unique(upbm$uniprot_swissprot_accession)))
kable(tab)
```

- Among these, about half map to mulitple transcript identifiers.

```{r ids2, echo=FALSE, fig.width=12}
## How many transcripts per accession do we find?
tab <- rbind(table(table(upbm$uniprot_swissprot_accession)))
barplot(tab)
```

**Caveat**: Mapping between single protein and unique transcripts?

## Missing values

An example data:

```{r}
library("MSnbase")
data(naset)
naset

table(is.na(naset))
table(fData(naset)$nNA)
```

Options are:

### Filtering

Remove missing values, or at least features or samples with excessive number of missing values:

```{r}
flt <- filterNA(naset)
processingData(flt)
any(is.na(filterNA(naset)))
```

### Data imputation

There are two types of mechanisms resulting in missing values in
LC/MSMS experiments.

- Missing values resulting from absence of detection of a feature,
  despite ions being present at detectable concentrations.  For
  example in the case of ion suppression or as a result from the
  stochastic, data-dependent nature of the MS acquisition
  method. These missing value are expected to be randomly distributed
  in the data and are defined as **missing at random** (MAR) or
  **missing completely at random** (MCAR).

- Biologically relevant missing values, resulting from the *absence*
  of the low abundance of ions (below the limit of detection of the
  instrument). These missing values are not expected to be randomly
  distributed in the data and are defined as **missing not at random**
  (MNAR).


![RSR KNN and MinDet imputation](./figure/imp-sim.png)
(`KNN` and `MinDet` - with Cosmin Lazar and Thomas Burger)

MNAR features should ideally be imputed with a **left-censor**
(minimum value, ~zero~, ...)  method. Conversely, it is recommended to
use **hot deck** methods (nearest neighbour, maximum likelihood, ...)
when data are missing at random.

```{r xv, echo=FALSE, fig.width=9, fig.heigth=9}
x <- impute(naset, "zero")
exprs(x)[exprs(x) != 0] <- 1

suppressPackageStartupMessages(library("gplots"))

heatmap.2(exprs(x), col = c("lightgray", "black"),
          scale = "none", dendrogram = "none",
          trace = "none", keysize = 0.5, key = FALSE,
          RowSideColors = ifelse(fData(x)$randna, "orange", "brown"),
          ColSideColors = rep(c("steelblue", "darkolivegreen"), each = 8))
```

```{r impute}
x <- impute(naset, method = "mixed",
            randna = fData(naset)$randna,
            mar = "knn", mnar = "min")
x
```

## Session information

```{r si}
sessionInfo()
```

| [Home](./README.md) | [Caveats](./caveats.md) | [Mapping](./mapping.md) | [Transfer learning](./transfer-learning.md) |

