# Integrating transcriptomics and proteomics data

Different approaches to data integration exist: (i) model- or
network-based approaches that identify common patterns in different
data sources as well as (ii) reference-based approaches, that map
different sources of data against a common reference.

The former are very versatile and rely on experiment-wide
clustering/modelling and crucially depend on reliably linking features
(explicitly via common identifiers or through functional
contextualisation). Transcript and protein measurement have previously
been combined and compared by linking the respective features by a
**common (gene) identifier** 
([1](http://www.ncbi.nlm.nih.gov/pubmed/21179022),
[2](http://www.ncbi.nlm.nih.gov/pubmed/22068331)). Such approaches are
often difficult to track and are susceptible to inconsistencies in the
relation between different data sources when, for example, multiple
transcripts are compared to ambiguous protein groups. The latter
approaches are a natural choice for data stemming from genomics,
transcriptomics, epigenomics, etc that directly rely on **mapping** their
data features along a **genome reference**.

# Mapping peptides to genomic coordinates

```{r env, echo=FALSE, warning=FALSE}
suppressPackageStartupMessages(library("Pbase"))
suppressPackageStartupMessages(library("rtracklayer"))
library("knitr")
opts_chunk$set(fig.width=12, fig.height=7)
data(p)
```

The **goal** is to map peptides from protein coordinates (1 to *L_p*)
to genomic coordinates.

```{r mapplot, echo=FALSE}
Pbase:::mapplot()
```

Illustration with the
[`Pbase`](http://bioconductor.org/packages/devel/bioc/html/Pbase.html)
Bioconductor package (devel version).

## Data

We have an example data, named `p`, composed of `r length(p)`
proteins, with UniProt accession numbers and Ensembl transcipt
identifers and each protein has a set experimentally observed
peptides:

```{r ids, echo=FALSE}
kable(cbind(Acc = seqnames(p),
            ENST = acols(p)$ENST,
            npep = elementLengths(pranges(p))),
      row.names = 0)
```

For example, `r seqnames(p)[5]`:

```{r pplot1, echo=FALSE}
plot(p[5])
```

## Genomic coordinates of the transcripts/exons

```{r etrid2grl, echo=TRUE, cache=TRUE}
grl <- etrid2grl(acols(p)$ENST)
pcgrl <- proteinCoding(grl)
```

```{r gviz1, echo=FALSE, cache=TRUE}
grTrack <- GeneRegionTrack(grl[[5]],
                           name = acols(p)$ENST[5])
grTrack2 <- GeneRegionTrack(pcgrl[[5]],
                           name = acols(p)$ENST[5])
ideoTrack <- IdeogramTrack(genome = "hg38",
                           chromosome = "chrX")
axisTrack <- GenomeAxisTrack()
plotTracks(list(ideoTrack, axisTrack, grTrack, grTrack2),
           add53 = TRUE, add35 = TRUE)
```

## Mapping peptides to the genome

```{r pmap}
res <- pmapToGenome(p, pcgrl)
```

```{r gviz2, echo=FALSE}
.res <- res[[5]]
pepTrack <- AnnotationTrack(start = start(.res),
                            end = end(.res),
                            chr = chrom(.res),
                            strand = strand(.res),
                            id = mcols(.res)$pepseq,
                            name = paste0(seqnames(p[5]),
                                " peptides"))
plotTracks(list(ideoTrack, axisTrack, grTrack, pepTrack),
           groupAnnotation = "id",
           just.group = "below",
           fontsize.group = 9,
           add53 = TRUE, add35 = TRUE)
```

## Detailed annotation tracks

Maintaining access to the raw MS data

```{r gviz3, echo=FALSE}
data(pms)

library("ggplot2")
details <- function(identifier, ...) {
    p <- plot(pms[[as.numeric(identifier)]], full=TRUE, plot=FALSE) + ggtitle("") 
    p <- p + theme_bw() + theme(axis.text.y = element_blank(),
                                axis.text.x = element_blank()) + 
                                labs(x = NULL, y = NULL)
    print(p, newpage=FALSE)
}

deTrack <- AnnotationTrack(start = start(.res),
                           end = end(.res),
                           genome = "hg38", chromosom = "chrX",
                           id = pcols(p)[[5]]$acquisitionNum,
                           name = "MS2 spectra",
                           stacking = "squish", fun = details)


plotTracks(list(ideoTrack, axisTrack, deTrack, grTrack),
           add53 = TRUE, add35 = TRUE)
```


# Multiple transcipts per protein

## Data

We use our example data, named `p`, composed of `r length(p)`
proteins, with UniProt accession numbers and Ensembl transcipt
identifers and each protein has a set experimentally observed
peptides:

```{r ids2, echo=FALSE}
kable(cbind(Acc = seqnames(p),
            ENST = acols(p)$ENST,
            npep = elementLengths(pranges(p))),
      row.names = 0)
```

If we hadn't the curated UniProt accession/Ensembl transcript
identifer maps, we would, for example, query an online repositary such
as the Ensembl Biomart instance.

```{r ens}
library("biomaRt")
ens <- useMart("ensembl", "hsapiens_gene_ensembl")
ens
```

```{r bm}
bm <- select(ens, keys = seqnames(p),
             keytype = "uniprot_swissprot_accession",
             columns = c(
                 "uniprot_swissprot_accession",
                 "ensembl_transcript_id"))

bm
```

```{r bm2, echo=FALSE}
k <- 6
sel <- bm$uniprot_swissprot_accession == seqnames(p)[k]
bm2 <- bm[sel, ]
eid <- bm2[, 2]
names(eid) <- bm2[, 1]
```

If we focus on `r seqnames(p)[k]` for example, we see that we
retrieve `r nrow(bm2)` possible transcript identifers, including our
annotated `r acols(p)$ENST[k]`.

```{r bm2tab, echo=FALSE}
kable(bm2, row.names = 0)
```

## Genomic coordinates

Let's fetch the coordinates of all possible transcipts, making sure
that the names of the Ensembl identifiers are used to name the grl
ranges (using `use.names = TRUE`). We obtain 30 sets of ranges for 9
proteins.

```{r pcgrl}
eid
grl <- etrid2grl(eid, ens, use.names = TRUE)
pcgrl <- proteinCoding(grl)
```

```{r givtr}
grTr <- lapply(pcgrl, function(i)
    GeneRegionTrack(i, name = mcols(i)$transcript[1]))

plotTracks(grTr)
```

## Discriminating transcripts

```{r protfromgenome, echo=FALSE, message=FALSE}
library("BSgenome.Hsapiens.NCBI.GRCh38")
if (!"chr1" %in% seqnames(BSgenome.Hsapiens.NCBI.GRCh38))
    seqnames(BSgenome.Hsapiens.NCBI.GRCh38)[1:23] <-
        paste0("chr", seqnames(BSgenome.Hsapiens.NCBI.GRCh38)[1:23])
```

We extract the transcript sequences, translate them into protein
sequences and align each to our original protein sequence.

```{r aln, warnings=FALSE}
library("BSgenome.Hsapiens.NCBI.GRCh38")
lseq <- lapply(getSeq(BSgenome.Hsapiens.NCBI.GRCh38, pcgrl),
               function(s) translate(unlist(s)))

laln <- sapply(lseq, pairwiseAlignment, aa(p[k]))
sapply(laln, nmatch)/width(aa(p[k]))
```

```{r align, echo=FALSE}
ki <- which.max(sapply(laln, nmatch))
writePairwiseAlignments(laln[[ki]])
```

We see that transcript number `r ki`, `r eid[ki]`, perfectly aligns
with our protein sequence. This is also the transcipt that corresponds
to the curated Ensembl transcript in `acols(p)$ENST`.

```{r checkk, echo=FALSE}
stopifnot(eid[ki] == acols(p)$ENST[k])
```

```{r map}
res <- pmapToGenome(p[k], pcgrl[ki])
```



```{r pepcoords2, echo=FALSE}
res <- res[[1]]
pepTr <- AnnotationTrack(start = start(res),
                         end = end(res),
                         chr = chrom(res),
                         strand = strand(res),
                         id = mcols(res)$pepseq,
                         group = mcols(res)$group,
                         fill = ifelse(mcols(res)$exonJunctions, "red", "steelblue"),
                         col = NULL,
                         name = mcols(res)$transcript[1])

plotTracks(list(grTr[[ki]], pepTr))
```

# Mapping MS peptides and RNA-Seq short reads

The last step of the mapping process is the combine the newly mapped
peptides and reads from RNA-Seq experiments. The figures below
illustrate this with data from Sheynkman et
al. ([2013](http://www.ncbi.nlm.nih.gov/pubmed/23629695),
[2014](http://www.ncbi.nlm.nih.gov/pubmed/25149441)) from the Jurkat
cell line (TIB-152). The
[mass spectrometry](https://db.systemsbiology.net/sbeams/cgi/PeptideAtlas/PASS_View?identifier=PASS00215)
and
[RNA-Seq](http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE45428)
(SRR791580) where processed with standard pipelines. 


```{r peptrack, echo=FALSE}
suppressPackageStartupMessages(library("Gviz"))
load("./data/peptrack.rda")
plotTracks(peptrack[-5])
plotTracks(peptrack)
```

```{r alntrack, echo=FALSE}
options(ucscChromosomeNames=FALSE)
load("./data/alntrack.rda")
alntrack[[2]]@reference <- "./data/mybam.bam"
plotTracks(alntrack, from = 30116807, to = 30186474)
```

### References

Laurent Gatto and Sebastian Gibb
(2014). [`Pbase`](http://bioconductor.org/packages/devel/bioc/html/Pbase.html):
Manipulating and exploring protein and proteomics data. R package
version 0.6.9. https://github.com/ComputationalProteomicsUnit/Pbase

Pang et al. Tools to covisualize and coanalyze proteomic data with
genomes and transcriptomes: validation of genes and alternative mRNA
splicing. J Proteome Res. 2014 Jan 3;13(1):84-98. doi:
10.1021/pr400820p. Epub 2013 Nov 12. PubMed
[PMID: 24152167](http://www.ncbi.nlm.nih.gov/pubmed/24152167).

| [Home](./README.md) | [Caveats](./Caveats.md) | [Mapping](./mapping.md) | [Transfer learning](./transfer-learning.md) |
